diff --git CMakeLists.txt CMakeLists.txt
index fcd917f..a1eb703 100644
--- CMakeLists.txt
+++ CMakeLists.txt
@@ -174,9 +174,15 @@ INSTALL(TARGETS ${PROJECT_NAME}
 ADD_HEADER_GROUP(${PROJECT_NAME}_HEADERS)
 ADD_SOURCE_GROUP(${PROJECT_NAME}_SOURCES)
 
+INCLUDE(GenerateExportHeader)
+GENERATE_EXPORT_HEADER(${PROJECT_NAME} EXPORT_FILE_NAME eigenpy/${PROJECT_NAME}_export.h)
 TARGET_INCLUDE_DIRECTORIES(${PROJECT_NAME} INTERFACE "$<BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}>")
 SET(PUBLIC_HEADER ${${PROJECT_NAME}_HEADERS})
 
+INSTALL(FILES
+  ${CMAKE_CURRENT_BINARY_DIR}/eigenpy/${PROJECT_NAME}_export.h
+  DESTINATION include/eigenpy)
+
 # Install package for ROS
 install(FILES package.xml DESTINATION share/eigenpy)
 
Submodule cmake contains modified content
diff --git cmake/python.cmake cmake/python.cmake
index 263f914..15323ea 100644
--- cmake/python.cmake
+++ cmake/python.cmake
@@ -55,7 +55,7 @@ ENDIF(CMAKE_VERSION VERSION_LESS "3.2")
 
 MACRO(FINDPYTHON)
 
-  IF(NOT CMAKE_VERSION VERSION_LESS "3.12")
+  IF(NOT CMAKE_VERSION VERSION_LESS "3.12" AND NOT WIN32)
 
     IF((DEFINED PYTHON_EXECUTABLE OR DEFINED Python_EXECUTABLE) AND NOT WIN32)
       IF(NOT DEFINED Python_EXCUTABLE)
@@ -99,7 +99,7 @@ MACRO(FINDPYTHON)
       SET(PYTHON_VERSION_PATCH       ${${_PYTHON_PREFIX}_VERSION_PATCH})
     ENDIF()
 
-  ELSE(NOT CMAKE_VERSION VERSION_LESS "3.12")
+  ELSE(NOT CMAKE_VERSION VERSION_LESS "3.12" AND NOT WIN32)
 
     FIND_PACKAGE(PythonInterp ${ARGN})
     IF (NOT ${PYTHONINTERP_FOUND} STREQUAL TRUE)
@@ -143,7 +143,7 @@ MACRO(FINDPYTHON)
     ENDIF (NOT ${PYTHON_VERSION_MAJOR} EQUAL ${PYTHONLIBS_VERSION_MAJOR} OR
            NOT ${PYTHON_VERSION_MINOR} EQUAL ${PYTHONLIBS_VERSION_MINOR})
 
-  ENDIF(NOT CMAKE_VERSION VERSION_LESS "3.12")
+  ENDIF(NOT CMAKE_VERSION VERSION_LESS "3.12" AND NOT WIN32)
 
   # Find PYTHON_LIBRARY_DIRS
   GET_FILENAME_COMPONENT(PYTHON_LIBRARY_DIRS "${PYTHON_LIBRARIES}" PATH)
diff --git include/eigenpy/computation-info.hpp include/eigenpy/computation-info.hpp
index b5d3378..4931bdf 100644
--- include/eigenpy/computation-info.hpp
+++ include/eigenpy/computation-info.hpp
@@ -8,11 +8,9 @@
 #include <Eigen/Core>
 #include <boost/python.hpp>
 
-#include "eigenpy/config.hpp"
-
 namespace eigenpy
 {
-  inline void EIGENPY_DLLEXPORT exposeComputationInfo()
+  inline void exposeComputationInfo()
   {
     boost::python::enum_<Eigen::ComputationInfo>("ComputationInfo")
     .value("Success",Eigen::Success)
diff --git include/eigenpy/decompositions/decompositions.hpp include/eigenpy/decompositions/decompositions.hpp
index 2779378..7a06c54 100644
--- include/eigenpy/decompositions/decompositions.hpp
+++ include/eigenpy/decompositions/decompositions.hpp
@@ -5,11 +5,11 @@
 #ifndef __eigenpy_decompositions_decompositions_hpp__
 #define __eigenpy_decompositions_decompositions_hpp__
 
-#include "eigenpy/config.hpp"
+#include "eigenpy/eigenpy_export.h"
 
 namespace eigenpy
 {
-  void EIGENPY_DLLEXPORT exposeDecompositions();
+  void EIGENPY_EXPORT exposeDecompositions();
 } // namespace eigenpy
 
 #endif // define __eigenpy_decompositions_decompositions_hpp__
diff --git include/eigenpy/eigenpy.hpp include/eigenpy/eigenpy.hpp
index 24c7b74..49f935d 100644
--- include/eigenpy/eigenpy.hpp
+++ include/eigenpy/eigenpy.hpp
@@ -1,6 +1,6 @@
 /*
  * Copyright 2014-2019, CNRS
- * Copyright 2018-2020, INRIA
+ * Copyright 2018-2019, INRIA
  */
 
 #ifndef __eigenpy_eigenpy_hpp__
@@ -8,7 +8,7 @@
 
 #include "eigenpy/fwd.hpp"
 #include "eigenpy/deprecated.hpp"
-#include "eigenpy/config.hpp"
+#include "eigenpy/eigenpy_export.h"
 
 #if EIGEN_VERSION_AT_LEAST(3,2,0)
 #include "eigenpy/ref.hpp"
@@ -28,7 +28,7 @@ namespace eigenpy
 {
 
   /* Enable Eigen-Numpy serialization for a set of standard MatrixBase instance. */
-  void EIGENPY_DLLEXPORT enableEigenPy();
+  void EIGENPY_EXPORT enableEigenPy();
 
   template<typename MatType>
   void enableEigenPySpecific();
diff --git include/eigenpy/geometry.hpp include/eigenpy/geometry.hpp
index 3fee5f3..71a4c69 100644
--- include/eigenpy/geometry.hpp
+++ include/eigenpy/geometry.hpp
@@ -1,20 +1,20 @@
 /*
  * Copyright 2014-2019, CNRS
- * Copyright 2018-2020, INRIA
+ * Copyright 2018-2019, INRIA
  */
 
 #ifndef __eigenpy_geometry_hpp__
 #define __eigenpy_geometry_hpp__
 
-#include "eigenpy/config.hpp"
+#include "eigenpy/eigenpy_export.h"
 
 namespace eigenpy
 {
   
-  void EIGENPY_DLLEXPORT exposeQuaternion();
-  void EIGENPY_DLLEXPORT exposeAngleAxis();
+  void EIGENPY_EXPORT exposeQuaternion();
+  void EIGENPY_EXPORT exposeAngleAxis();
   
-  void EIGENPY_DLLEXPORT exposeGeometryConversion();
+  void EIGENPY_EXPORT exposeGeometryConversion();
   
 } // namespace eigenpy
 
diff --git include/eigenpy/solvers/preconditioners.hpp include/eigenpy/solvers/preconditioners.hpp
index 46540d2..c609a77 100644
--- include/eigenpy/solvers/preconditioners.hpp
+++ include/eigenpy/solvers/preconditioners.hpp
@@ -17,12 +17,12 @@
 #ifndef __eigenpy_preconditioners_hpp__
 #define __eigenpy_preconditioners_hpp__
 
-#include "eigenpy/config.hpp"
+#include "eigenpy/eigenpy_export.h"
 
 namespace eigenpy
 {
   
-  void EIGENPY_DLLEXPORT exposePreconditioners();
+  void EIGENPY_EXPORT exposePreconditioners();
   
 } // namespace eigenpy
 
diff --git include/eigenpy/solvers/solvers.hpp include/eigenpy/solvers/solvers.hpp
index b85a392..628105d 100644
--- include/eigenpy/solvers/solvers.hpp
+++ include/eigenpy/solvers/solvers.hpp
@@ -1,17 +1,29 @@
 /*
- * Copyright 2017-2020 CNRS INRIA
+ * Copyright 2017, Justin Carpentier, LAAS-CNRS
+ *
+ * This file is part of eigenpy.
+ * eigenpy is free software: you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * as published by the Free Software Foundation, either version 3 of
+ * the License, or (at your option) any later version.
+ * eigenpy is distributed in the hope that it will be
+ * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.  You should
+ * have received a copy of the GNU Lesser General Public License along
+ * with eigenpy.  If not, see <http://www.gnu.org/licenses/>.
  */
 
 #ifndef __eigenpy_solvers_hpp__
 #define __eigenpy_solvers_hpp__
 
-#include "eigenpy/config.hpp"
+#include "eigenpy/eigenpy_export.h"
 
 namespace eigenpy
 {
   struct SolversScope {};
   
-  void EIGENPY_DLLEXPORT exposeSolvers();
+  void EIGENPY_EXPORT exposeSolvers();
   
 } // namespace eigenpy
 
diff --git include/eigenpy/version.hpp include/eigenpy/version.hpp
index 1d0b98f..77cf084 100644
--- include/eigenpy/version.hpp
+++ include/eigenpy/version.hpp
@@ -1,12 +1,12 @@
 //
-// Copyright (c) 2019-2020 INRIA
+// Copyright (c) 2019 INRIA
 //
 
 #ifndef __eigenpy_version_hpp__
 #define __eigenpy_version_hpp__
 
 #include "eigenpy/config.hpp"
-#include "eigenpy/config.hpp"
+#include "eigenpy/eigenpy_export.h"
 
 #include <string>
 
@@ -18,7 +18,7 @@ namespace eigenpy
   ///        the following standard:
   ///        EIGENPY_MINOR_VERSION.EIGENPY_MINOR_VERSION.EIGENPY_PATCH_VERSION
   ///
-  std::string EIGENPY_DLLEXPORT printVersion(const std::string & delimiter = ".");
+  std::string EIGENPY_EXPORT printVersion(const std::string & delimiter = ".");
   
   ///
   /// \brief Checks if the current version of EigenPy is at least the version provided
@@ -31,7 +31,7 @@ namespace eigenpy
   /// \returns true if the current version of EigenPy is greater than the version provided
   ///        by the input arguments.
   ///
-  bool EIGENPY_DLLEXPORT checkVersionAtLeast(unsigned int major_version,
+  bool EIGENPY_EXPORT checkVersionAtLeast(unsigned int major_version,
                                           unsigned int minor_version,
                                           unsigned int patch_version);
 }
diff --git python/main.cpp python/main.cpp
index 925d9cf..11b35d5 100644
--- python/main.cpp
+++ python/main.cpp
@@ -51,10 +51,7 @@ BOOST_PYTHON_MODULE(eigenpy)
             "Returns True if A is approximately equal to B, within the precision determined by prec.");
     bp::def("is_approx",(bool (*)(const MatrixXd &, const MatrixXd &))&is_approx<MatrixXd,MatrixXd>,
             bp::args("A","B"),
-    "Returns True if A is approximately equal to B..");
-    
-//    EXPOSE_IS_APPROX(MatrixXd);
-//    EXPOSE_IS_APPROX(MatrixXf);
+            "Returns True if A is approximately equal to B.");
   }
   
   exposeDecompositions();
diff --git src/decompositions/decompositions.cpp src/decompositions/decompositions.cpp
index 95856ec..cdfe764 100644
--- src/decompositions/decompositions.cpp
+++ src/decompositions/decompositions.cpp
@@ -5,6 +5,8 @@
 #include <boost/python.hpp>
 #include <Eigen/Core>
 
+#include "eigenpy/decompositions/decompositions.hpp"
+
 #include "eigenpy/decompositions/EigenSolver.hpp"
 #include "eigenpy/decompositions/SelfAdjointEigenSolver.hpp"
 #include "eigenpy/decompositions/LLT.hpp"
@@ -16,14 +18,13 @@ namespace eigenpy
   {
     using namespace Eigen;
     namespace bp = boost::python;
-    
-    EigenSolverVisitor<Eigen::MatrixXd>::expose("EigenSolver");
-    SelfAdjointEigenSolverVisitor<Eigen::MatrixXd>::expose("SelfAdjointEigenSolver");
-    LLTSolverVisitor<Eigen::MatrixXd>::expose("LLT");
-    LDLTSolverVisitor<Eigen::MatrixXd>::expose("LDLT");
+
+    EigenSolverVisitor<MatrixXd>::expose("EigenSolver");
+    SelfAdjointEigenSolverVisitor<MatrixXd>::expose("SelfAdjointEigenSolver");
+    LLTSolverVisitor<MatrixXd>::expose("LLT");
+    LDLTSolverVisitor<MatrixXd>::expose("LDLT");
 
     {
-      using namespace Eigen;
       bp::enum_<DecompositionOptions>("DecompositionOptions")
       .value("ComputeFullU",ComputeFullU)
       .value("ComputeThinU",ComputeThinU)
@@ -36,6 +37,6 @@ namespace eigenpy
       .value("BAx_lx",BAx_lx)
       ;
     }
-    
+
   }
 } // namespace eigenpy
diff --git src/solvers/solvers.cpp src/solvers/solvers.cpp
index 99e9a70..7a6e88a 100644
--- src/solvers/solvers.cpp
+++ src/solvers/solvers.cpp
@@ -8,6 +8,10 @@
 
 #include "eigenpy/solvers/solvers.hpp"
 #include "eigenpy/solvers/ConjugateGradient.hpp"
+#include "eigenpy/decompositions/EigenSolver.hpp"
+#include "eigenpy/decompositions/SelfAdjointEigenSolver.hpp"
+#include "eigenpy/decompositions/LLT.hpp"
+#include "eigenpy/decompositions/LDLT.hpp"
 
 #if EIGEN_VERSION_AT_LEAST(3,3,5)
   #include "eigenpy/solvers/LeastSquaresConjugateGradient.hpp"
