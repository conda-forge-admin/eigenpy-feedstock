diff --git README.md README.md
index f590200..b1262b3 100644
--- README.md
+++ README.md
@@ -9,11 +9,12 @@ EigenPy â€” Efficient Python bindings between Numpy/Eigen
   <a href="https://conda.anaconda.org/conda-forge"><img src="https://anaconda.org/conda-forge/eigenpy/badges/installer/conda.svg" alt="Anaconda-Server Badge"/></a>
 </p>
 
-**EigenPy** is an open source framework which allows to bind the famous [Eigen](http://eigen.tuxfamily.org) in Python as NumPy object (as matrix or array).
-**EigenPy** allows the sharing of memory between Numpy and Eigen avoiding memory allocation.
-**EigenPy** fully support Eigen::Ref avoiding memory allocation.
-**EigenPy** also exposes the Geometry module of Eigen for easy code prototyping.
-**EigenPy** also supports the basic matrix decomposion routines of Eigen such as the Cholesky decomposition, SVD decomposition, QR decomposition, and etc.
+**EigenPy** is an open source framework which allows to bind the famous [Eigen](http://eigen.tuxfamily.org) C++ library in Python.
+**EigenPy** provides: 
+ - the fill sharing of memory between Numpy and Eigen avoiding memory allocation.
+ - the full support Eigen::Ref avoiding memory allocation.
+ - the exposition of the Geometry module of Eigen for easy code prototyping.
+ - the basic matrix decomposion routines of Eigen such as the Cholesky decomposition, SVD decomposition, QR decomposition, and etc.
 
 ## Setup
 
diff --git include/eigenpy/numpy-allocator.hpp include/eigenpy/numpy-allocator.hpp
index 59885b3..e0fd882 100644
--- include/eigenpy/numpy-allocator.hpp
+++ include/eigenpy/numpy-allocator.hpp
@@ -20,8 +20,8 @@ namespace eigenpy
     {
       typedef typename SimilarMatrixType::Scalar Scalar;
       
-      PyArrayObject * pyArray = (PyArrayObject*) PyArray_SimpleNew(nd, shape,
-                                                                   NumpyEquivalentType<Scalar>::type_code);
+      PyArrayObject * pyArray = (PyArrayObject*) call_PyArray_SimpleNew(nd, shape,
+                                                                        NumpyEquivalentType<Scalar>::type_code);
       
       // Copy data
       EigenAllocator<SimilarMatrixType>::copy(mat,pyArray);
@@ -40,11 +40,10 @@ namespace eigenpy
       typedef typename SimilarMatrixType::Scalar Scalar;
       enum { NPY_ARRAY_MEMORY_CONTIGUOUS = SimilarMatrixType::IsRowMajor ? NPY_ARRAY_CARRAY : NPY_ARRAY_FARRAY };
       
-      PyArrayObject * pyArray = (PyArrayObject*) PyArray_New(&PyArray_Type, nd, shape,
-                                                             NumpyEquivalentType<Scalar>::type_code, NULL,
-                                                             mat.data(), 0,
-                                                             NPY_ARRAY_MEMORY_CONTIGUOUS | NPY_ARRAY_ALIGNED,
-                                                             NULL);
+      PyArrayObject * pyArray = (PyArrayObject*) call_PyArray_New(nd, shape,
+                                                                  NumpyEquivalentType<Scalar>::type_code,
+                                                                  mat.data(),
+                                                                  NPY_ARRAY_MEMORY_CONTIGUOUS | NPY_ARRAY_ALIGNED);
       
       return pyArray;
     }
@@ -69,11 +68,10 @@ namespace eigenpy
       typedef typename SimilarMatrixType::Scalar Scalar;
       enum { NPY_ARRAY_MEMORY_CONTIGUOUS_RO = SimilarMatrixType::IsRowMajor ? NPY_ARRAY_CARRAY_RO : NPY_ARRAY_FARRAY_RO };
       
-      PyArrayObject * pyArray = (PyArrayObject*) PyArray_New(&PyArray_Type, nd, shape,
-                                                             NumpyEquivalentType<Scalar>::type_code, NULL,
-                                                             const_cast<SimilarMatrixType &>(mat.derived()).data(), 0,
-                                                             NPY_ARRAY_MEMORY_CONTIGUOUS_RO | NPY_ARRAY_ALIGNED,
-                                                             NULL);
+      PyArrayObject * pyArray = (PyArrayObject*) call_PyArray_New(nd, shape,
+                                                                  NumpyEquivalentType<Scalar>::type_code,
+                                                                  const_cast<SimilarMatrixType &>(mat.derived()).data(),
+                                                                  NPY_ARRAY_MEMORY_CONTIGUOUS_RO | NPY_ARRAY_ALIGNED);
       
       return pyArray;
     }
diff --git include/eigenpy/numpy.hpp include/eigenpy/numpy.hpp
index c8780a2..180c59d 100644
--- include/eigenpy/numpy.hpp
+++ include/eigenpy/numpy.hpp
@@ -19,11 +19,32 @@
 
 #include <numpy/noprefix.h>
 
-#define EIGENPY_GET_PY_ARRAY_TYPE(array) PyArray_ObjectType(reinterpret_cast<PyObject *>(array), 0)
+#if defined _WIN32 || defined __CYGWIN__
+  #define EIGENPY_GET_PY_ARRAY_TYPE(array) \
+    call_PyArray_ObjectType(reinterpret_cast<PyObject *>(array), 0)
+#else
+  #define EIGENPY_GET_PY_ARRAY_TYPE(array) \
+    PyArray_ObjectType(reinterpret_cast<PyObject *>(array), 0)
+#endif
 
 namespace eigenpy
 {
   void EIGENPY_DLLEXPORT import_numpy();
 }
 
+#if defined _WIN32 || defined __CYGWIN__
+namespace eigenpy
+{
+  EIGENPY_DLLEXPORT PyObject*  call_PyArray_SimpleNew(int nd, npy_intp * shape, int np_type);
+
+  EIGENPY_DLLEXPORT PyObject* call_PyArray_New(int nd, npy_intp * shape, int np_type, void * data_ptr, int options);
+
+  EIGENPY_DLLEXPORT int call_PyArray_ObjectType(PyObject *, int);
+}
+#else
+  #define call_PyArray_SimpleNew PyArray_SimpleNew
+  #define call_PyArray_New(nd,shape,np_type,data_ptr,options) \
+    PyArray_New(&PyArray_Type,nd,shape,np_type,NULL,data_ptr,0,options,NULL)
+#endif
+
 #endif // ifndef __eigenpy_numpy_hpp__
diff --git src/numpy.cpp src/numpy.cpp
index 61a91f3..4e7531b 100644
--- src/numpy.cpp
+++ src/numpy.cpp
@@ -14,4 +14,23 @@ namespace eigenpy
       PyErr_SetString(PyExc_ImportError, "numpy.core.multiarray failed to import");
     }
   }
+
+#if defined _WIN32 || defined __CYGWIN__
+
+  PyObject* call_PyArray_SimpleNew(int nd, npy_intp * shape, int np_type)
+  {
+    return PyArray_SimpleNew(nd,shape,np_type);
+  }
+
+  PyObject* call_PyArray_New(int nd, npy_intp * shape, int np_type, void * data_ptr, int options)
+  {
+    return PyArray_New(&PyArray_Type,nd,shape,np_type,NULL,data_ptr,0,options,NULL);
+  }
+  
+  int call_PyArray_ObjectType(PyObject * obj, int val)
+  {
+    return PyArray_ObjectType(obj,val);
+  }
+
+#endif
 }
